# 📋 共同開発ガイドライン

> **⚠️ 重要: 新しいチャットセッションを開始する際は、必ず最初にこのファイルを確認してください**
>
> このガイドラインは、プロジェクトの進行に応じて**随時更新**されます。
> 最新の状態を確認してから開発を開始してください。

---

**最終更新日**: 2025-11-22
**バージョン**: 1.0.0

---

## 🎯 最優先原則

**スパゲッティコードを絶対に作らない**
- 修正不可能な状態に陥ることを最も恐れる
- 短期的な部分修正よりも、長期的な保守性を重視
- 不安がある場合は、必ず質問して確認する

---

## 📚 目次

1. [包括的な修正の判断基準](#1-包括的な修正の判断基準)
2. [開発の優先順位](#2-開発の優先順位)
3. [日本語コメント規約](#3-日本語コメント規約)
4. [質問のタイミングと方法](#4-質問のタイミングと方法)
5. [変更ファイルの記述ルール](#5-変更ファイルの記述ルール)
6. [コードレビュー基準](#6-コードレビュー基準)
7. [Git コミットメッセージ規約](#7-git-コミットメッセージ規約)
8. [トラブルシューティング](#8-トラブルシューティング)
9. [ガイドラインの更新について](#9-ガイドラインの更新について)

---

## 1. 包括的な修正の判断基準

### 基本方針
「包括的な修正」の範囲は**各修正の性質と影響範囲によって柔軟に判断**します。

### 判断のフローチャート

```
修正を行う
  ↓
この修正は他のコンポーネント/ファイルに影響するか？
  ├─ YES → 影響範囲をリストアップ
  │         ↓
  │       影響を受ける部分も同時に修正
  │         ↓
  │       整合性テストを考慮
  │
  └─ NO → 単独での修正でOK
           ↓
         ただし、将来的な拡張性を考慮
```

### 具体的な判断例

#### ✅ 良い例：適切な範囲の包括的修正

**ケース: ボタンのデザインを変更**
```
修正範囲:
1. Button3D.tsx - デザイン変更
2. 関連する型定義 (types.ts) - 新しいプロパティがあれば追加
3. App.tsx - ボタンを呼び出している箇所の確認
4. 他の類似ボタン - 同じデザインシステムなら統一

✅ スパゲッティコード化を防ぐため、関連部分を漏れなく修正
```

**ケース: 状態管理ロジックの変更**
```
修正範囲:
1. 状態を持つコンポーネント
2. その状態を参照する子コンポーネント
3. 状態を変更するイベントハンドラ
4. 型定義
5. 状態に依存するアニメーション/条件分岐

✅ 状態の整合性を保つため、すべての依存部分を確認
```

#### ❌ 悪い例：範囲が不適切

**過度に狭い修正**
```
❌ Button3D.tsx のスタイルだけ変更
   → App.tsx での呼び出し方が古いまま
   → 型定義が更新されず、TypeScriptエラー
   → スパゲッティコード化
```

**過度に広い修正**
```
❌ ボタンの色を変えるだけなのに、プロジェクト全体のカラーシステムを再設計
   → 本来の目的から逸脱
   → 時間の無駄
```

### スパゲッティコード防止チェックリスト

修正前に以下を確認：

- [ ] この修正によって、他のファイルとの整合性が崩れないか？
- [ ] 同様のパターンが他にもある場合、それも統一すべきか？
- [ ] 型定義は最新の実装と一致しているか？
- [ ] 将来的にこの部分を拡張するとき、修正しやすいか？
- [ ] コメントやドキュメントは最新の実装を反映しているか？

---

## 2. 開発の優先順位

### 優先順位（降順）

```
1. 機能の正確性 ⭐⭐⭐⭐⭐
   └─ 要件を正確に満たす
   └─ バグがない
   └─ エッジケースを考慮

2. コードの可読性 ⭐⭐⭐⭐
   └─ 他の開発者が理解しやすい
   └─ 初心者でも読める日本語コメント
   └─ 明確な変数名・関数名

3. 保守性・拡張性 ⭐⭐⭐⭐
   └─ 将来の変更に強い設計
   └─ モジュール化されている
   └─ 依存関係が明確

4. デザインパターンの一貫性 ⭐⭐⭐
   └─ プロジェクト全体で統一されたパターン
   └─ 予測可能な構造
   └─ ベストプラクティスに準拠

5. パフォーマンス ⭐⭐
   └─ 通常は最低優先
   └─ 明らかなパフォーマンス低下がある場合は優先度UP
```

### 優先順位の例外ルール

**パフォーマンスが最優先になるケース：**
- アニメーションが60FPSを下回る
- 初期ロード時間が3秒を超える
- メモリリークが発生している
- レンダリングがブロックされる

→ この場合、可読性や一貫性よりもパフォーマンス最適化を優先

---

## 3. 日本語コメント規約

### 基本方針
**すべてのコメントは日本語で、初心者にもわかるように記述**

### コメントのレベル

#### Level 1: ファイル全体の説明（必須）
```typescript
// Button3D.tsx
// 3D空間内に配置するインタラクティブなボタンコンポーネント
//
// 【機能】
// - ホバー時のスケールアニメーション
// - クリックイベントのハンドリング
// - Text3Dを使用した3Dテキスト表示
//
// 【使用例】
// <Button3D
//   text="クリック"
//   font={fontUrl}
//   position={[0, -2, 0]}
//   onClick={handleClick}
// />
```

#### Level 2: 関数・コンポーネントの説明（必須）
```typescript
/**
 * 3Dボタンコンポーネント
 *
 * @param text - ボタンに表示するテキスト
 * @param font - 3DフォントのURL（JSON形式）
 * @param position - 3D空間内の位置 [x, y, z]
 * @param onClick - クリック時に実行される関数
 *
 * @remarks
 * - ホバー時に1.1倍にスケール
 * - 発光エフェクトあり
 * - レイキャストでホバー判定
 */
export function Button3D({ text, font, position, onClick }: Button3DProps) {
```

#### Level 3: 複雑なロジックの説明（推奨）
```typescript
// ホバー検出のロジック
// 1. マウスポインタの2D座標からレイを飛ばす
// 2. ボタンのグループ内のすべてのメッシュと交差判定
// 3. 交差があればホバー状態に設定
// 4. カーソルの形状も "pointer" に変更
const handlePointerMove = () => {
  if (!groupRef.current) return;

  raycaster.setFromCamera(pointer, camera);
  const intersects = raycaster.intersectObject(groupRef.current, true);
  setHovered(intersects.length > 0);

  document.body.style.cursor = intersects.length > 0 ? "pointer" : "auto";
};
```

#### Level 4: 初心者向けの補足説明（推奨）
```typescript
// lerp（線形補間）を使って滑らかにアニメーション
// lerp(現在値, 目標値, 係数) = 徐々に目標値に近づく
// 例: lerp(0, 10, 0.1) = 1 → 次は lerp(1, 10, 0.1) = 1.9 → ...
groupRef.current.scale.lerp(
  new THREE.Vector3(targetScale, targetScale, targetScale),
  0.1
);
```

### コメント不要なケース

以下は自明なので、コメント不要：
```typescript
// ❌ 不要なコメント
const [hovered, setHovered] = useState(false); // ホバー状態を管理

// ✅ 変数名が明確なのでコメント不要
const [hovered, setHovered] = useState(false);
```

---

## 4. 質問のタイミングと方法

### 必ず質問すべきケース

#### 🔴 最優先で質問（作業を止めて確認）
- 要件が曖昧で、複数の解釈が可能
- 既存のコードの意図が不明（推測で修正すると危険）
- 大規模なリファクタリングが必要
- 破壊的変更（後方互換性がなくなる）

#### 🟡 作業前に確認（プラン提示時）
- 複数の実装方法があり、どれが望ましいか判断が必要
- UI/UXのデザイン判断が必要
- パフォーマンスとトレードオフがある選択
- 影響範囲が広い変更

#### 🟢 作業後に確認（実装後のレビュー）
- 実装方針が正しかったか確認
- より良い方法があるか意見を求める

### 質問のフォーマット

```markdown
## ❓ 確認事項

### 【状況】
現在、〇〇を実装していますが、△△の部分で判断が必要です。

### 【質問】
1. A案: [説明]
   - メリット: ...
   - デメリット: ...

2. B案: [説明]
   - メリット: ...
   - デメリット: ...

どちらが望ましいでしょうか？または別の方法がありますか？

### 【影響範囲】
この変更により、以下のファイルに影響があります：
- src/ComponentA.tsx
- src/ComponentB.tsx
```

---

## 5. 変更ファイルの記述ルール

### 必須フォーマット

**すべての回答の最後に以下を記載：**

```markdown
---

## 📝 変更したファイル

### 修正
- `ファイルパス` - 変更内容の簡潔な説明

### 追加
- `ファイルパス` - 追加した内容の簡潔な説明

### 削除
- `ファイルパス` - 削除理由

### 設定変更
- `ファイルパス` - 設定の変更内容
```

### 具体例

```markdown
## 📝 変更したファイル

### 修正
- `src/Button3D.tsx` - デバッグコードを削除、本来のText3Dデザインに復元
- `src/App.tsx` - Scenes コンポーネントのデバッグログを削除
- `src/types.ts` - Button3DProps に optional な size プロパティを追加

### 追加
- `src/utils/animations.ts` - アニメーション用のユーティリティ関数を追加
- `src/hooks/useHover.ts` - ホバー検出のカスタムフック

### 削除
- `src/OldButton.tsx` - Button3D に統合したため削除

### 設定変更
- `package.json` - `@types/babel__core` を devDependencies に追加
- `tsconfig.node.json` - `composite: true` を追加（プロジェクト参照エラー解決）
```

---

## 6. コードレビュー基準

### 自己チェックリスト（提出前に確認）

#### ✅ 機能の正確性
- [ ] 要件をすべて満たしているか
- [ ] エッジケースを考慮しているか
- [ ] エラーハンドリングは適切か
- [ ] TypeScriptの型は正確か

#### ✅ コードの可読性
- [ ] 変数名・関数名は明確か
- [ ] ネストが深すぎないか（3階層まで）
- [ ] 1つの関数は1つの責務か
- [ ] 日本語コメントは十分か

#### ✅ 保守性・拡張性
- [ ] 将来の変更に対応しやすいか
- [ ] ハードコードを避けているか
- [ ] マジックナンバーに定数名をつけているか
- [ ] コンポーネントは適切に分割されているか

#### ✅ デザインパターンの一貫性
- [ ] プロジェクト内の他のコードと同じパターンか
- [ ] React/TypeScriptのベストプラクティスに準拠しているか
- [ ] フォルダ構成のルールに従っているか

#### ✅ パフォーマンス（必要な場合）
- [ ] 不要な再レンダリングを避けているか
- [ ] useCallback/useMemo を適切に使用しているか
- [ ] 重い処理を非同期化しているか

---

## 7. Git コミットメッセージ規約

### フォーマット
```
[種類] 簡潔な変更内容（50文字以内）

詳細な説明（必要に応じて）
- 変更理由
- 影響範囲
- 注意点

関連Issue: #123
```

### 種類の例
- `[追加]` - 新機能の追加
- `[修正]` - バグ修正
- `[変更]` - 既存機能の変更
- `[削除]` - ファイル・機能の削除
- `[リファクタ]` - コードの整理（機能変更なし）
- `[ドキュメント]` - ドキュメントのみの変更
- `[設定]` - 設定ファイルの変更

### 例
```
[追加] Button3Dコンポーネントを実装

3D空間内に配置可能なインタラクティブボタンを追加
- ホバー時のスケールアニメーション
- Text3Dを使用した3Dテキスト表示
- クリックイベントのハンドリング

関連Issue: #45
```

---

## 8. トラブルシューティング

### スパゲッティコード化のサイン

以下の兆候があれば、リファクタリングを検討：

🚨 **危険信号**
- 1つのファイルが500行を超える
- 関数のネストが5階層以上
- 同じコードが3箇所以上にコピペされている
- 修正するたびに他の機能が壊れる
- TypeScriptのエラーを `any` で回避している
- グローバル変数が増え続けている

### リファクタリングの判断基準

```
新機能を追加する際、既存コードの修正が必要な場合：
  ↓
修正箇所が3ファイル以下？
  ├─ YES → そのまま修正
  └─ NO → リファクタリングを提案
           ↓
         ユーザーに確認を取る
```

---

## 9. ガイドラインの更新について

### 更新ルール

このガイドラインは**生きたドキュメント**です。プロジェクトの進行に応じて、以下のタイミングで更新されます：

#### 📌 定期更新のタイミング
- 新しいコーディング規約が追加された時
- 既存のルールが変更された時
- プロジェクトの技術スタックが変更された時
- 重要な設計判断が行われた時
- チーム内でのベストプラクティスが確立された時

#### 📌 更新時の手順
1. `DEVELOPMENT_GUIDELINES.md` を編集
2. ファイル冒頭の **最終更新日** を更新
3. **バージョン** を更新（メジャー変更は 1.x.x、マイナー変更は x.1.x）
4. 変更内容を [変更履歴](#変更履歴) セクションに追記
5. Git コミットメッセージに `[ドキュメント] ガイドライン更新` と記載

#### 📌 バージョン管理
- **メジャー更新 (x.0.0)**: ガイドラインの大幅な変更、破壊的変更
- **マイナー更新 (0.x.0)**: 新しいセクションの追加、既存ルールの拡張
- **パッチ更新 (0.0.x)**: 誤字修正、軽微な補足

---

## 📖 変更履歴

### v1.0.0 (2025-11-22)
- 初版作成
- 包括的な修正の判断基準を追加
- 開発の優先順位を定義
- 日本語コメント規約を策定
- 質問のタイミングと方法を明確化
- 変更ファイルの記述ルールを設定
- コードレビュー基準を追加
- Git コミットメッセージ規約を追加
- トラブルシューティングガイドを追加

---

## 📞 連絡先・質問

このガイドラインについて不明点や改善提案がある場合：

1. **緊急の質問**: チャットで直接質問
2. **改善提案**: このファイルに対するプルリクエスト
3. **ルールの追加依頼**: プロジェクトマネージャーに相談

---

## ✅ 新しいチャットセッション開始時のチェックリスト

新しいAIアシスタントとチャットを始める際、以下を確認：

- [ ] このガイドラインファイルを最初に読み込んだか
- [ ] 最終更新日を確認し、最新版であることを確認したか
- [ ] 現在のプロジェクトの状況を把握したか（README.md、package.json 等）
- [ ] 最近のコミット履歴を確認したか
- [ ] 未解決のIssueやTODOコメントを確認したか

---

**このガイドラインを遵守することで、長期的に保守可能で高品質なコードベースを維持できます。**

**スパゲッティコードを作らず、チーム全員が理解しやすいコードを書きましょう！**
